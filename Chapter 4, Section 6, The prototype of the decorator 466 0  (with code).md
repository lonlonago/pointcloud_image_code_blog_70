##  Python basics (a full set of nanny-level tutorials) 

###  Chapter IV 

![avatar]( 9a4dfd49a7a24a8ba97c3415e57cff7c.png) 

 Content review: 1. Functions can be passed as parameters 2. Functions can be returned as return values 3. Function names can be assigned as variables 

 ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574569150
 ```  
![avatar]( 3040fb95cff046789f3ee9f6bac79c5f.png) 

 The push-to-process of the decorator  

 ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574569150
 ```  
Summarize: 

Decorator: - > Required to remember the final conclusion, the decorator is essentially a closure, function: without changing the original function call. Add new functions to the function. Straightforward: You can add new functions before and after the function, but do not change the original code 

Where the user logs in, log. How to write the universal decorator: def wrapper (fn): wrapper: decorator, fn: objective function def inner (* args, ** kwargs): #before the objective function is executed... ret = fn (* args, ** kwargs) #Execute the objective function #After the objective function is executed... return ret return inner Never add () ** 

###  Remember the conclusion, the process doesn't matter, it depends on personal interests... 

** 

